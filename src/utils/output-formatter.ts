import * as fs from 'fs/promises';
import * as path from 'path';
import { 
  AnalysisResult, 
  BusinessRule, 
  Output, 
  FileSystemError 
} from '../types';

export interface FormatterOptions {
  includeMetadata?: boolean;
  includeSourceReferences?: boolean;
  groupByCategory?: boolean;
  sortByPriority?: boolean;
}

export class OutputFormatter {
  constructor(private options: FormatterOptions = {}) {
    this.options = {
      includeMetadata: true,
      includeSourceReferences: true,
      groupByCategory: true,
      sortByPriority: true,
      ...options
    };
  }

  async formatAndSave(
    result: AnalysisResult, 
    outputPath: string, 
    format: 'json' | 'markdown'
  ): Promise<void> {
    const output = format === 'json' 
      ? this.formatAsJSON(result)
      : this.formatAsMarkdown(result);

    try {
      // Ensure output directory exists
      const outputDir = path.dirname(outputPath);
      await fs.mkdir(outputDir, { recursive: true });

      // Write the formatted output
      await fs.writeFile(outputPath, output.content, 'utf-8');
      
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      throw new FileSystemError(`Failed to save output: ${message}`, {
        outputPath,
        format,
        error: message
      });
    }
  }

  formatAsJSON(result: AnalysisResult): Output {
    return {
      format: 'json',
      content: JSON.stringify(result, null, 2)
    };
  }

  formatAsMarkdown(result: AnalysisResult): Output {
    const lines: string[] = [];

    // Header
    lines.push(`# Business Rules for ${result.applicationName}`);
    lines.push('');

    // Metadata section
    if (this.options.includeMetadata) {
      lines.push('## Analysis Summary');
      lines.push('');
      lines.push(`- **Analysis Date:** ${new Date(result.analysisDate).toLocaleDateString()}`);
      lines.push(`- **Total Files Analyzed:** ${result.totalFilesAnalyzed}`);
      lines.push(`- **Total Business Rules:** ${result.summary.totalRules}`);
      lines.push(`- **High Priority Rules:** ${result.summary.highPriorityRules}`);
      lines.push(`- **User-Facing Rules:** ${result.summary.userFacingRules}`);
      lines.push('');
    }

    // Rules organized by category
    if (this.options.groupByCategory) {
      const categorizedRules = this.categorizeRules(result.businessRules);
      
      for (const [category, rules] of Object.entries(categorizedRules)) {
        lines.push(`## ${category}`);
        lines.push('');

        const sortedRules = this.options.sortByPriority 
          ? this.sortRulesByPriority(rules)
          : rules;

        for (const rule of sortedRules) {
          lines.push(...this.formatRule(rule));
        }
        lines.push('');
      }
    } else {
      // All rules in one section
      lines.push('## Business Rules');
      lines.push('');

      const sortedRules = this.options.sortByPriority 
        ? this.sortRulesByPriority(result.businessRules)
        : result.businessRules;

      for (const rule of sortedRules) {
        lines.push(...this.formatRule(rule));
      }
    }

    // Footer with generation info
    lines.push('---');
    lines.push('');
    lines.push('*This document was automatically generated by Khodkar CLI.*');
    lines.push(`*Generated on: ${new Date().toLocaleString()}*`);

    return {
      format: 'markdown',
      content: lines.join('\n')
    };
  }

  private formatRule(rule: BusinessRule): string[] {
    const lines: string[] = [];

    // Rule title with priority indicator
    const priorityEmoji = this.getPriorityEmoji(rule.priority);
    lines.push(`### ${priorityEmoji} ${rule.title}`);
    lines.push('');

    // Rule description
    lines.push(rule.description);
    lines.push('');

    // Tags if present
    if (rule.tags.length > 0) {
      lines.push(`**Tags:** ${rule.tags.map(tag => `\`${tag}\``).join(', ')}`);
      lines.push('');
    }

    // Source reference
    if (this.options.includeSourceReferences && rule.source) {
      const sourceRef = rule.source.startLine && rule.source.endLine
        ? `${rule.source.file}:${rule.source.startLine}-${rule.source.endLine}`
        : rule.source.file;
      lines.push(`*Source: ${sourceRef}*`);
      lines.push('');
    }

    return lines;
  }

  private categorizeRules(rules: BusinessRule[]): Record<string, BusinessRule[]> {
    const categorized: Record<string, BusinessRule[]> = {};

    for (const rule of rules) {
      if (!categorized[rule.category]) {
        categorized[rule.category] = [];
      }
      categorized[rule.category].push(rule);
    }

    return categorized;
  }

  private sortRulesByPriority(rules: BusinessRule[]): BusinessRule[] {
    const priorityOrder = { high: 3, medium: 2, low: 1 };
    
    return [...rules].sort((a, b) => {
      // First sort by priority
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
      if (priorityDiff !== 0) return priorityDiff;

      // Then by user-facing (user-facing first)
      if (a.userFacing !== b.userFacing) {
        return b.userFacing ? 1 : -1;
      }

      // Finally by title alphabetically
      return a.title.localeCompare(b.title);
    });
  }

  private getPriorityEmoji(priority: 'high' | 'medium' | 'low'): string {
    const emojiMap = {
      high: 'ðŸ”´',
      medium: 'ðŸŸ¡',
      low: 'ðŸŸ¢'
    };
    return emojiMap[priority];
  }

  // Static utility methods
  static async validateOutputPath(outputPath: string): Promise<void> {
    try {
      const outputDir = path.dirname(outputPath);
      await fs.access(outputDir);
    } catch {
      // Directory doesn't exist, try to create it
      try {
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        throw new FileSystemError(`Cannot create output directory: ${message}`, {
          outputPath,
          error: message
        });
      }
    }
  }

  static getOutputExtension(format: 'json' | 'markdown'): string {
    return format === 'json' ? '.json' : '.md';
  }

  static generateDefaultOutputPath(
    directory: string, 
    format: 'json' | 'markdown'
  ): string {
    const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const projectName = path.basename(directory);
    const extension = OutputFormatter.getOutputExtension(format);
    
    return path.join(
      directory, 
      `business-rules-${projectName}-${timestamp}${extension}`
    );
  }

  static async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  static async getFileStats(filePath: string): Promise<{
    size: number;
    created: Date;
    modified: Date;
  }> {
    try {
      const stats = await fs.stat(filePath);
      return {
        size: stats.size,
        created: stats.birthtime,
        modified: stats.mtime
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error';
      throw new FileSystemError(`Cannot get file stats: ${message}`, {
        filePath,
        error: message
      });
    }
  }

  // Template methods for custom formatting
  protected formatHeader(result: AnalysisResult): string[] {
    return [`# Business Rules for ${result.applicationName}`, ''];
  }

  protected formatFooter(): string[] {
    return [
      '---',
      '',
      '*This document was automatically generated by Khodkar CLI.*',
      `*Generated on: ${new Date().toLocaleString()}*`
    ];
  }
}
